<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smart Document Scanner</title>
<style>
  body { font-family:'Sarabun', sans-serif; background:#f5f5f5; margin:0; padding:20px; text-align:center;}
  h2 { color:#06C755; }
  input, button { padding:10px 20px; margin:10px; font-size:16px; border-radius:6px; }
  #previewContainer { display:flex; flex-wrap:wrap; justify-content:center; gap:10px; margin-top:20px;}
  .pageCanvas { border:1px solid #555; border-radius:8px; max-width:160px; }
  .btn { background:#06C755; color:#fff; border:none; cursor:pointer; transition:.3s;}
  .btn:hover { background:#049645; }
</style>
</head>
<body>

<h2>üìÑ Smart Document Scanner</h2>
<p>‡∏ñ‡πà‡∏≤‡∏¢‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏´‡∏•‡∏≤‡∏¢‡∏´‡∏ô‡πâ‡∏≤ ‚Üí ‡∏Ñ‡∏£‡∏≠‡∏õ‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞ ‚Üí ‡πÅ‡∏¢‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤ (‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠) ‚Üí ‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß‡∏ó‡∏±‡∏ô‡∏ó‡∏µ</p>

<input type="file" id="cameraInput" accept="image/*" capture="environment" multiple>
<br>
<button class="btn" onclick="exportPDF()">Export PDF</button>
<div id="previewContainer"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
const { jsPDF } = window.jspdf;
let pagesArray = [];

function distance(p1,p2){ return Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2); }
function sortPoints(pts){ 
  return pts.sort((a,b)=>a.y-b.y).sort((a,b)=>a.x-b.x);
}

document.getElementById('cameraInput').addEventListener('change', async e=>{
  const files = Array.from(e.target.files);
  for(const file of files){
    const img = new Image();
    img.src = URL.createObjectURL(file);
    await img.decode();
    const canvases = await processDocument(img);
    for(const c of canvases){
      pagesArray.push(c);
      document.getElementById('previewContainer').appendChild(c);
    }
  }
});

async function processDocument(img){
  return new Promise(resolve=>{
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img,0,0,img.width,img.height);

    cv['onRuntimeInitialized']=()=>{
      let src = cv.imread(canvas);
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY,0);

      // Shadow removal
      let morph = new cv.Mat();
      let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(15,15));
      cv.morphologyEx(gray, morph, cv.MORPH_CLOSE, kernel);
      cv.subtract(morph, gray, gray);
      cv.normalize(gray, gray, 0, 255, cv.NORM_MINMAX);

      // Edge detection
      let edges = new cv.Mat();
      cv.Canny(gray, edges, 50,150);

      // Contours
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let maxArea=0, maxCnt=null;
      for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt,false);
        if(area>maxArea){ maxArea=area; maxCnt=cnt; }
      }

      if(maxCnt){
        let approx = new cv.Mat();
        cv.approxPolyDP(maxCnt, approx, 0.02*cv.arcLength(maxCnt,true), true);
        if(approx.rows===4){
          let pts=[];
          for(let i=0;i<4;i++){ pts.push({x:approx.intPtr(i,0)[0], y:approx.intPtr(i,0)[1]}); }
          pts = sortPoints(pts);

          const width = Math.max(distance(pts[0], pts[1]), distance(pts[2], pts[3]));
          const height = Math.max(distance(pts[0], pts[3]), distance(pts[1], pts[2]));

          const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[pts[0].x,pts[0].y, pts[1].x,pts[1].y, pts[2].x,pts[2].y, pts[3].x,pts[3].y]);
          const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[0,0,width,0,width,height,0,height]);
          let M = cv.getPerspectiveTransform(srcTri,dstTri);
          let warped = new cv.Mat();
          cv.warpPerspective(src, warped, M, new cv.Size(width,height));

          // Enhancement
          cv.cvtColor(warped, warped, cv.COLOR_RGBA2RGB);
          let enhanced = new cv.Mat();
          cv.cvtColor(warped, enhanced, cv.COLOR_RGB2GRAY);
          cv.equalizeHist(enhanced, enhanced);

          const outCanvas = document.createElement('canvas');
          outCanvas.width = width;
          outCanvas.height = height;
          cv.imshow(outCanvas, enhanced);

          // Book Split
          if(width>height){
            const halfWidth = Math.floor(width/2);
            const leftCanvas = document.createElement('canvas');
            leftCanvas.width = halfWidth;
            leftCanvas.height = height;
            leftCanvas.getContext('2d').drawImage(outCanvas,0,0,halfWidth,height,0,0,halfWidth,height);

            const rightCanvas = document.createElement('canvas');
            rightCanvas.width = width-halfWidth;
            rightCanvas.height = height;
            rightCanvas.getContext('2d').drawImage(outCanvas,halfWidth,0,width-halfWidth,height,0,0,width-halfWidth,height);

            resolve([leftCanvas,rightCanvas]);
          } else {
            resolve([outCanvas]);
          }

          warped.delete(); enhanced.delete(); M.delete(); srcTri.delete(); dstTri.delete();
        }
        approx.delete();
      } else { resolve([canvas]); }

      src.delete(); gray.delete(); morph.delete(); edges.delete(); contours.delete(); hierarchy.delete();
    }
  });
}

// Export PDF
function exportPDF(){
  if(pagesArray.length===0){ alert("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏´‡πâ Export"); return; }
  const pdf = new jsPDF();
  pagesArray.forEach((c,i)=>{
    if(i>0) pdf.addPage();
    const imgData = c.toDataURL('image/jpeg',1.0);
    pdf.addImage(imgData,'JPEG',0,0,pdf.internal.pageSize.getWidth(), pdf.internal.pageSize.getHeight());
  });
  pdf.save('scanned_document.pdf');
}
</script>
</body>
</html>
